#!/usr/bin/env python3

# requires python3-tk, python3-numpy

import re
import numpy as np
from subprocess import run, PIPE

class GUI(object):
    '''
    Only implement Tk GUI for the moment
    '''
    def __init__(self, n_points, old_cal_inv, new_cal=None):
        from tkinter import Tk, Canvas
        from math import ceil, sqrt
        
        self.n_points = n_points
        self.old_cal_inv = old_cal_inv
        self.new_cal = new_cal

        self.n_cols = int(ceil(sqrt(n_points)))
        self.n_rows = int(ceil(n_points / self.n_cols))

        self.X, self.Y = None, None
        self.point, self.points = {}, []
        self.index = -1

        self.root = Tk()
        self.root.attributes('-fullscreen', True)
        self.canvas = Canvas(self.root)
        self.canvas.bind('<Configure>', self.resize)
        self.canvas.pack(expand=True, fill='both')
        self.sensitive = False
        self.legend_y = None

    def transform(self, x, y, cal):
        p = np.matrix([[x], [y], [1]])
        out = np.matmul(cal, p)
        return out.item(0), out.item(1)

    def run(self):
        self.root.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Button-1>', self.click)
        self.root.mainloop()
        return self.points

    def resize(self, event):
        self.X, self.Y = event.width, event.height
        self.draw_legends()
        self.next_point()

    def legend(self, text, colour='#000'):
        self.canvas.create_text(self.X/2, self.legend_y, text=text, fill=colour)
        self.legend_y += 12

    def draw_legends(self):
        self.legend_y = self.Y * 0.3
        self.legend('Esc to cancel.')
        self.legend('Raw self.point in black')
        self.legend('Old cal self.point in blue', '#00F')
        self.legend('Target self.point in red', '#F00')
        if self.new_cal is not None:
            self.legend('New cal self.point in green', '#0F0')

    def next_point(self):
        self.index += 1
        if self.index >= self.n_points:
            self.sensitive = False
            self.root.after(1000, self.root.destroy)
        else:
            self.sensitive = True
            x = 0.1 + 0.8*(self.index % self.n_cols)/(self.n_cols - 1)
            y = 0.1 + 0.8*(self.index // self.n_cols)/(self.n_rows - 1)
            self.point = {'sx': x, 'sy': y}

            self.draw_target(self.point['sx'], self.point['sy'])

    def cross(self, px, py, colour):
        x, y = px*self.X, py*self.Y
        self.canvas.create_line(x-10, y, x+10, y, fill=colour)
        self.canvas.create_line(x, y-10, x, y+10, fill=colour)

    def draw_target(self, px, py):
        x, y = px*self.X, py*self.Y
        self.canvas.create_oval(x-10, y-10, x+10, y+10, outline='#F00', width=3)
        self.cross(px, py, '#F00')

    def cancel_cal(self, _):
        print('Calibration cancelled')
        self.points.clear()
        self.root.destroy()

    def indicator(self, sx, sy, px, py, colour):
        self.canvas.create_line(self.X*sx, self.Y*sy, self.X*px, self.Y*py, fill=colour)
        self.cross(px, py, colour)

    def click(self, event):
        if not self.sensitive:
            return
        self.sensitive = False
    
        sx, sy = self.point['sx'], self.point['sy']

        ox, oy = event.x/self.X, event.y/self.Y  # old-calibrated
        self.indicator(sx, sy, ox, oy, '#00F')

        ux, uy = self.transform(ox, oy, self.old_cal_inv)  # uncalibrated
        self.indicator(sx, sy, ux, uy, '#000')

        if self.new_cal is not None:
            nx, ny = self.transform(ux, uy, self.new_cal)  # new-calibrated (test only)
            self.indicator(sx, sy, nx, ny, '#0F0')

        self.point.update({'mx': ux, 'my': uy})
        self.points.append(self.point)

        self.canvas.after(500, self.next_point)

class xcal_base(object):
    def xinput(self, *args):
        '''
        Placeholder for actual code       
        '''
        pass

    def get_devs(self):
        '''
        Placeholder for actual code       
        '''
        pass

    def print_devs(self, devs):
        '''
        Placeholder for actual code       
        '''
        pass

    def choose_preferred(self, devs):
        '''
        Placeholder for actual code       
        '''
        pass

    def choose_dev(self, devs, preferred):
        '''
        Placeholder for actual code       
        '''
        pass

    def read_cal(self, dev):
        '''
        Placeholder for actual code       
        '''
        pass


    def choose_points(self):
        '''
        Placeholder for actual code       
        '''
        pass

    def ask(self, q):
        '''
        Placeholder for actual code       
        '''
        pass
        
    def use_cal(dev, new_cal):
        '''
        Placeholder for actual code       
        '''
        pass

    def transform(self, x, y, cal):
        p = np.matrix([[x], [y], [1]])
        out = np.matmul(cal, p)
        return out.item(0), out.item(1)

    #def show_tk(self, self.n_points, old_cal_inv, new_cal=None):
        

    def fit(self, screen_pts, mouse_pts):
        from math import log10
        m_screen = np.matrix([[*p, 1] for p in screen_pts])
        m_mouse = np.matrix([[*p, 1] for p in mouse_pts])
        m_transform, residuals, rank, singular = np.linalg.lstsq(m_mouse, m_screen)
        quality = -log10(residuals.sum())
        return m_transform, quality


    def calibrate(self, points, disable_rot):
        if disable_rot:
            '''
            [mx 1] [a 0]   [sx 1]
            [mx 1] [e 1] = [sx 1]
            [... ]         [... ]
            
            [my 1] [d 0]   [sy 1]
            [my 1] [f 1] = [sy 1]
            [... ]         [... ]
            '''
            tx, qual_x = self.fit(screen_pts=((p['sx'],) for p in self.points),
                                  mouse_pts=((p['mx'],) for p in self.points))
            ty, qual_y = self.fit(screen_pts=((p['sy'],) for p in self.points),
                                  mouse_pts=((p['my'],) for p in self.points))
            m_transform = np.matrix([
                [tx[0, 0], 0,        0],
                [0,        ty[0, 0], 0],
                [tx[1, 0], ty[1, 0], 1]])
            quality = min(qual_x, qual_y)
        else:
            '''
            m_mouse * m_transform = m_screen
            [mx my 1] [a b 0]   [sx sy 1]
            [mx my 1] [c d 0] = [sx sy 1]
            [...    ] [e f 1]   [...    ]
            '''
            m_transform, quality = self.fit(screen_pts=[(p['sx'], p['sy']) for p in self.points],
                                       mouse_pts=[(p['mx'], p['my']) for p in self.points])
            m_transform[:, 2] = ([0], [0], [1])

        m_transform = m_transform.getT()
        return m_transform, quality

    def run(self):
        new_cal = None
        if self.ask('Calibrate?'):
            self.n_points = self.choose_points(num_points)
            if disable_rot is None:
                disable_rot = self.ask('Disable rotation?')

            self.points = self.show_tk(self.n_points, old_cal_inv)
            if self.points:
                new_cal, quality = self.calibrate(points, disable_rot)

                print('New calibration:')
                print(new_cal)
                print('Quality (should be at least 3): %.1f' % quality)
                print()

        if self.ask('Test?'):
            self.n_points = self.choose_points()
            self.show_tk(self.n_points, old_cal_inv, new_cal)

        if new_cal is not None and self.ask('Use calibration?'):
            self.use_cal(dev, new_cal)

    def __init__(self, dev_to_calibrate=None, num_points=None, disable_rot=False):
        self.devs = self.get_devs()
        preferred = self.choose_preferred()
        dev = self.choose_dev(preferred, dev_to_calibrate)

        old_cal, old_cal_inv = self.read_cal(dev)


class xcal_xinput(xcal_base):
    prop_name = 'libinput Calibration Matrix'

    def xinput(self, *args):
        return run(args=('/usr/bin/xinput', *args),
                   stdout=PIPE, check=True,
                   universal_newlines=True).stdout
    
    
    def get_devs(self):
        devs = {int(groups[1]): groups[0] for groups in
                re.findall(r'â†³ (\w.+\w)\s+id=(\d+)\D+slave *pointer',
                           xinput('--list', '--short'))}
        if not devs:
            print('No suitable input devices found')
            exit(1)
        return devs
    
    
    def print_devs(self, devs):
        print('Pointer devices:')
        print('%4s %35s' % ('ID', 'Name'))
        for i, name in sorted(devs.items()):
            print('%4d %35s' % (i, name))
        print()
    
    
    def choose_preferred(self, devs):
        preferred = [i for (i, n) in devs.items() if 'touch' in n.lower()]
        if preferred:
            return preferred[0]
        return next(iter(devs.keys()))
    
    
    def choose_dev(self, devs, preferred):
        while True:
            devstr = input('Device to calibrate [%d]: ' % preferred)
            if not devstr:
                return preferred
            try:
                dev = int(devstr)
            except ValueError:
                continue
            if dev in devs.keys():
                return dev
    
    
    def read_cal(self, dev):
        stdout = xinput('--list-props', str(dev))
        line = re.search(prop_name + r'.*:\s+(\S.+)', stdout)
        if not line:
            print('Cal property not set; is this an xinput device?')
            exit(1)
        vals = np.matrix(line.group(1)).reshape(3, 3)
    
        print('Old calibration:')
        print(vals)
        print()
        return vals, np.linalg.inv(vals)
    
    
    def ask(self, q):
        do = input(q + ' [y]: ')
        return (do or 'y').lower() == 'y'
    
    
    def choose_points(self):
        p_min, default = 3, 4
    
        while True:
            p_str = input('Point count (min %d) [%d]: ' %
                          (p_min, default))
            if not p_str:
                return default
            try:
                p = int(p_str)
            except ValueError:
                continue
    
            if p >= p_min:
                return p
    
    def use_cal(self, dev, new_cal):
        cal_array = [str(x)+',' for x in new_cal.flatten().tolist()[0]]
        xinput('--set-prop', str(dev), prop_name, *cal_array)
    


#main()
