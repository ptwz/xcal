#!/usr/bin/env python3

# requires python3-tk, python3-numpy

import re
import numpy as np
from subprocess import run, PIPE

from tkinter import Tk, Canvas, simpledialog
class GUI(object):
    '''
    Only implement Tk GUI for the moment.

    Handles all UI related actions for a calibrator, will be
    instanciated from there.

    This will take over user communication and main loop,
    as soon as the calibrator has been set up and passes
    new information to the calibrator as soon as it is available.
    '''
    def __init__(self, calibrator, new_cal=None):
        self.index = -1
        self.calibrator = calibrator
        self.root = Tk()


    def ask_yesno(self, text, yes, no):
        if simpledialog.askyesno(text):
            yes()
        else:
            no()

    def ask_int(self, text, default=None):
        return simpledialog.askinteger("", text)#, default=default)

    def show_info(self, text):
        return simpledialog.showinfo(text)

    def run(self):
        self.canvas.bind('<Configure>', self.calibrator.ui_ready())
        self.root.mainloop()
        return self.points

    def show_workarea(self):
        #self.root.attributes('-fullscreen', True)
        self.canvas = Canvas(self.root)
        self.canvas.pack(expand=True, fill='both')
        self.sensitive = False
        self.legend_y = None

        self.canvas.bind('<Configure>', self.resize)
        self.root.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Button-1>', self.click)

    def resize(self, event):
        self.X, self.Y = event.width, event.height
        self.draw_legends()
        self.next_point()

    def legend(self, text, colour='#000'):
        self.canvas.create_text(self.X/2, self.legend_y, text=text, fill=colour)
        self.legend_y += 12

    def draw_legends(self):
        self.legend_y = self.Y * 0.3
        self.legend('Esc to cancel.')
        self.legend('Raw self.point in black')
        self.legend('Old cal self.point in blue', '#00F')
        self.legend('Target self.point in red', '#F00')
        #if self.new_cal is not None:
        #    self.legend('New cal self.point in green', '#0F0')

    def next_point(self):
        self.index += 1
        if self.index >= self.n_points:
            self.sensitive = False
            self.root.after(1000, self.root.destroy)
        else:
            self.sensitive = True
            x = 0.1 + 0.8*(self.index % self.n_cols)/(self.n_cols - 1)
            y = 0.1 + 0.8*(self.index // self.n_cols)/(self.n_rows - 1)
            self.point = {'sx': x, 'sy': y}

            self.draw_target(self.point['sx'], self.point['sy'])

    def cross(self, px, py, colour):
        x, y = px*self.X, py*self.Y
        self.canvas.create_line(x-10, y, x+10, y, fill=colour)
        self.canvas.create_line(x, y-10, x, y+10, fill=colour)

    def draw_target(self, px, py):
        x, y = px*self.X, py*self.Y
        self.canvas.create_oval(x-10, y-10, x+10, y+10, outline='#F00', width=3)
        self.cross(px, py, '#F00')

    def cancel_cal(self, _):
        print('Calibration cancelled')
        self.points.clear()
        self.root.destroy()

    def indicator(self, sx, sy, px, py, colour):
        self.canvas.create_line(self.X*sx, self.Y*sy, self.X*px, self.Y*py, fill=colour)
        self.cross(px, py, colour)

    def click(self, event):
        if not self.sensitive:
            return
        self.sensitive = False

        sx, sy = self.point['sx'], self.point['sy']

        ox, oy = event.x/self.X, event.y/self.Y  # old-calibrated
        self.indicator(sx, sy, ox, oy, '#00F')

        ux, uy = self.calibrator.transform(ox, oy, self.calibrator.old_cal_inv)  # uncalibrated
        self.indicator(sx, sy, ux, uy, '#000')

        if self.calibrator.new_cal is not None:
            nx, ny = self.transform(ux, uy, self.calibrator.new_cal)  # new-calibrated (test only)
            self.indicator(sx, sy, nx, ny, '#0F0')

        self.point.update({'mx': ux, 'my': uy})
        self.points.append(self.point)

        self.canvas.after(500, self.next_point)

class xcal_base(object):
    def get_devs(self):
        '''
        Placeholder for actual code
        '''
        pass

    def print_devs(self, devs):
        '''
        Placeholder for actual code
        '''
        pass

    def choose_preferred(self, devs):
        '''
        Placeholder for actual code
        '''
        pass

    def choose_dev(self, devs, preferred):
        '''
        Placeholder for actual code
        '''
        pass

    def read_cal(self, dev):
        '''
        Placeholder for actual code
        '''
        pass


    def choose_points(self):
        '''
        Placeholder for actual code
        '''
        pass

    def ask(self, q):
        '''
        Placeholder for actual code
        '''
        pass

    def use_cal(dev, new_cal):
        '''
        Placeholder for actual code
        '''
        pass

    def transform(self, x, y, cal):
        # TBD: Make cal selectable by flags, maybe makes more sense?
        p = np.matrix([[x], [y], [1]])
        out = np.matmul(cal, p)
        return out.item(0), out.item(1)

    def fit(self, screen_pts, mouse_pts):
        from math import log10
        m_screen = np.matrix([[*p, 1] for p in screen_pts])
        m_mouse = np.matrix([[*p, 1] for p in mouse_pts])
        m_transform, residuals, rank, singular = np.linalg.lstsq(m_mouse, m_screen)
        quality = -log10(residuals.sum())
        return m_transform, quality


    def calibrate(self, points, disable_rot):
        if disable_rot:
            '''
            [mx 1] [a 0]   [sx 1]
            [mx 1] [e 1] = [sx 1]
            [... ]         [... ]

            [my 1] [d 0]   [sy 1]
            [my 1] [f 1] = [sy 1]
            [... ]         [... ]
            '''
            tx, qual_x = self.fit(screen_pts=((p['sx'],) for p in self.points),
                                  mouse_pts=((p['mx'],) for p in self.points))
            ty, qual_y = self.fit(screen_pts=((p['sy'],) for p in self.points),
                                  mouse_pts=((p['my'],) for p in self.points))
            m_transform = np.matrix([
                [tx[0, 0], 0,        0],
                [0,        ty[0, 0], 0],
                [tx[1, 0], ty[1, 0], 1]])
            quality = min(qual_x, qual_y)
        else:
            '''
            m_mouse * m_transform = m_screen
            [mx my 1] [a b 0]   [sx sy 1]
            [mx my 1] [c d 0] = [sx sy 1]
            [...    ] [e f 1]   [...    ]
            '''
            m_transform, quality = self.fit(screen_pts=[(p['sx'], p['sy']) for p in self.points],
                                       mouse_pts=[(p['mx'], p['my']) for p in self.points])
            m_transform[:, 2] = ([0], [0], [1])

        m_transform = m_transform.getT()
        return m_transform, quality


    def state_init(self):
        self.state = self.state_init
        self.n_points = n_points
        self.old_cal_inv = old_cal_inv
        self.new_cal = new_cal

        self.n_cols = int(ceil(sqrt(n_points)))
        self.n_rows = int(ceil(n_points / self.n_cols))

        self.X, self.Y = None, None
        self.point, self.points = {}, []
        self.index = -1

        new_cal = None
        self.ui.ask_yesno('Calibrate?', yes=self.state_start_cal, no=self.state_test)

    def state_start_cal(self):
        self.state = self.state_start_cal
        self.n_points = self.choose_points(num_points)
        #if self.disable_rot is None:
        #    self.disable_rot = self.ui.ask_yesno('Disable rotation?')
        # TODO please do better here!
        disable_rot = False

        self.points = self.show_tk(self.n_points, old_cal_inv)
        if self.points:
            new_cal, quality = self.calibrate(points, disable_rot)
            message = 'New calibration:'
            message += "\n"+str(new_cal)
            message += '\nQuality (should be at least 3): %.1f' % quality
            self.ui.show_info(message)

    def state_test(self):
        self.n_points = self.choose_points()
        self.show_tk(self.n_points, old_cal_inv, new_cal)

    def ui_ready(self):
        self.state()

    def run(self):
        from math import ceil, sqrt

        self.n_points = n_points
        self.old_cal_inv = old_cal_inv
        self.new_cal = new_cal

        self.n_cols = int(ceil(sqrt(n_points)))
        self.n_rows = int(ceil(n_points / self.n_cols))

        self.X, self.Y = None, None
        self.point, self.points = {}, []
        self.index = -1

        #if new_cal is not None and self.ui.ask_yesno('Use calibration?'):
        #    self.use_cal(dev, new_cal)

    def __init__(self, ui, dev_to_calibrate=None, num_points=None, disable_rot=False):
        '''
        Create a new calibrator instance.

        Takes the UI base class and instanciates it.
        '''
        self.ui = ui(self)
        self.devs = self.get_devs()
        preferred = self.choose_preferred(self.devs)
        dev = self.choose_dev(preferred)

        self.old_cal, self.old_cal_inv = self.read_cal(dev)

        self.state = self.state_init

class xcal_xinput(xcal_base):
    prop_name = 'libinput Calibration Matrix'

    def xinput(self, *args):
        return run(args=('/usr/bin/xinput', *args),
                   stdout=PIPE, check=True,
                   universal_newlines=True).stdout


    def get_devs(self):
        devs = {int(groups[1]): groups[0] for groups in
                re.findall(r'â†³ (\w.+\w)\s+id=(\d+)\D+slave *pointer',
                           self.xinput('--list', '--short'))}
        if not devs:
            print('No suitable input devices found')
            exit(1)
        return devs


    def print_devs(self, devs):
        msg = "\n".join(('Pointer devices:',
                        '%4s %35s' % ('ID', 'Name')))
        
        for i, name in sorted(devs.items()):
            msg+=('\n%4d %35s' % (i, name))
        self.ui.show_info(msg)

    def choose_preferred(self, devs):
        preferred = [i for (i, n) in devs.items() if 'touch' in n.lower()]
        if preferred:
            return preferred[0]
        return next(iter(devs.keys()))


    def choose_dev(self, preferred):
        while True:

            devstr = self.ui.ask_int('Device to calibrate:' , preferred)
            try:
                dev = int(devstr)
            except ValueError:
                continue
            if dev in self.devs.keys():
                return dev


    def read_cal(self, dev):
        stdout = self.xinput('--list-props', str(dev))
        line = re.search(prop_name + r'.*:\s+(\S.+)', stdout)
        if not line:
            print('Cal property not set; is this an xinput device?')
            exit(1)
        vals = np.matrix(line.group(1)).reshape(3, 3)

        print('Old calibration:')
        print(vals)
        print()
        return vals, np.linalg.inv(vals)


    def choose_points(self):
        p_min, default = 3, 4

        while True:
            p_str = self.ui.ask_int('Point count (min %d): ' % p_min, default)
            try:
                p = int(p_str)
            except ValueError:
                continue

            if p >= p_min:
                return p

    def use_cal(self, dev, new_cal):
        cal_array = [str(x)+',' for x in new_cal.flatten().tolist()[0]]
        self.xinput('--set-prop', str(dev), prop_name, *cal_array)


xcal_xinput(GUI)
#main()
