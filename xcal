#!/usr/bin/env python3

# requires python3-tk, python3-numpy

import re
import numpy as np
import math
from subprocess import run, PIPE

from tkinter import Tk, Canvas, messagebox, simpledialog, Frame, Label, Button, IntVar, Entry

class GUI(object):
    '''
    Only implement Tk GUI for the moment.

    Handles all UI related actions for a calibrator, will be
    instanciated from there.

    This will take over user communication and main loop,
    as soon as the calibrator has been set up and passes
    new information to the calibrator as soon as it is available.
    '''
    def __init__(self, calibrator, new_cal=None):
        self.index = -1
        self.calibrator = calibrator
        self.root = Tk()
        self.calibrator_click = None
        self.canvas = Canvas(self.root)
        self.frame = Frame(self.canvas)#, height=self.Y//2, width=self.X//2 )
        self.X = 640
        self.Y = 480
        self.window = self.canvas.create_window((self.X//2, self.Y//2), window=self.frame)
        self.canvas.pack(expand=True, fill='both')
        self.canvas.bind('<Configure>', self.calibrator.ui_ready)

    def clear_frame(self):
        for widget in self.frame.winfo_children():
            widget.destroy()

    def ask_yesno(self, text, yes, no):
        label = Label(self.frame, text=text)

        def done_yes():
            self.clear_frame()
            yes()
        def done_no():
            self.clear_frame()
            no()

        btn_yes = Button(self.frame, text="Yes", command=done_yes)
        btn_no = Button(self.frame, text="No", command=done_no)
        label.grid(row=0, column=1)
        btn_no.grid(row=1, column=0)
        btn_yes.grid(row=1, column=2)

    def ask_int(self, text, default=None, when_done=None):
        #return simpledialog.askinteger("", text)#, default=default)
        label = Label(self.frame, text=text)
        v = IntVar()
        entry = Entry(self.frame, textvariable=v)

        def done():
            self.clear_frame()
            when_done(v)

        btn_on = Button(self.frame, text="OK", command=done)
        label.grid(row=0, column=0)
        entry.grid(row=0, column=1)
        btn_on.grid(row=0, column=2)

    def show_info(self, text, done):
        messagebox.showinfo(text)
        done()

    def run(self):
        self.root.mainloop()

    def show_workarea(self, when_done):
        #self.root.attributes('-fullscreen', True)
        self.sensitive = False
        self.legend_y = None

        # TODO: Do better ;)
        self.when_done = when_done
        self.canvas.bind('<Configure>', self.resize)
        self.root.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Escape>', self.cancel_cal)
        self.canvas.bind('<Button-1>', self.click)

    def after(self, seconds, func):
        self.root.after(int(seconds*1000.), func)

    def resize(self, event):
        self.X, self.Y = event.width, event.height
        self.draw_legends()
        self.when_done()

    def legend(self, text, colour='#000'):
        self.canvas.create_text(self.X/2, self.legend_y, text=text, fill=colour)
        self.legend_y += 12

    def draw_legends(self):
        self.legend_y = self.Y * 0.3
        self.legend('Esc to cancel.')
        self.legend('Raw self.point in black')
        self.legend('Old cal self.point in blue', '#00F')
        self.legend('Target self.point in red', '#F00')
        #if self.new_cal is not None:
        #    self.legend('New cal self.point in green', '#0F0')

    def next_point(self, sx, sy, click_handler=None):
        if click_handler is not None:
            self.calibrator_click = click_handler

        self.draw_target(sx, sy)

    def cross(self, px, py, colour):
        x, y = px*self.X, py*self.Y
        self.canvas.create_line(x-10, y, x+10, y, fill=colour)
        self.canvas.create_line(x, y-10, x, y+10, fill=colour)

    def draw_target(self, px, py):
        x, y = px*self.X, py*self.Y
        self.canvas.create_oval(x-10, y-10, x+10, y+10, outline='#F00', width=3)
        self.cross(px, py, '#F00')

    def cancel_cal(self, _):
        print('Calibration cancelled')
        self.points.clear()
        self.root.destroy()

    def indicator(self, sx, sy, px, py, colour):
        self.canvas.create_line(self.X*sx, self.Y*sy, self.X*px, self.Y*py, fill=colour)
        self.cross(px, py, colour)

    def click(self, event):
        if not self.sensitive:
            return
        self.sensitive = False

        sx, sy = self.point['sx'], self.point['sy']
        ex, ey = event.x, event.y
        self.calibrator.got_click(sx, sy, ex, ey)

class xcal_base(object):
    def get_devs(self):
        '''
        Placeholder for actual code
        '''
        pass

    def print_devs(self, devs):
        '''
        Placeholder for actual code
        '''
        pass

    def choose_preferred(self, devs):
        '''
        Placeholder for actual code
        '''
        pass

    def read_cal(self, dev):
        '''
        Placeholder for actual code
        '''
        pass


    def choose_points(self):
        '''
        Placeholder for actual code
        '''
        pass

    def ask(self, q):
        '''
        Placeholder for actual code
        '''
        pass

    def use_cal(dev, new_cal):
        '''
        Placeholder for actual code
        '''
        pass

    def transform(self, x, y, cal):
        # TBD: Make cal selectable by flags, maybe makes more sense?
        p = np.matrix([[x], [y], [1]])
        out = np.matmul(cal, p)
        return out.item(0), out.item(1)

    def fit(self, screen_pts, mouse_pts):
        from math import log10
        m_screen = np.matrix([[*p, 1] for p in screen_pts])
        m_mouse = np.matrix([[*p, 1] for p in mouse_pts])
        m_transform, residuals, rank, singular = np.linalg.lstsq(m_mouse, m_screen)
        quality = -log10(residuals.sum())
        return m_transform, quality


    def calibrate(self, points, disable_rot):
        if disable_rot:
            '''
            [mx 1] [a 0]   [sx 1]
            [mx 1] [e 1] = [sx 1]
            [... ]         [... ]

            [my 1] [d 0]   [sy 1]
            [my 1] [f 1] = [sy 1]
            [... ]         [... ]
            '''
            tx, qual_x = self.fit(screen_pts=((p['sx'],) for p in self.points),
                                  mouse_pts=((p['mx'],) for p in self.points))
            ty, qual_y = self.fit(screen_pts=((p['sy'],) for p in self.points),
                                  mouse_pts=((p['my'],) for p in self.points))
            m_transform = np.matrix([
                [tx[0, 0], 0,        0],
                [0,        ty[0, 0], 0],
                [tx[1, 0], ty[1, 0], 1]])
            quality = min(qual_x, qual_y)
        else:
            '''
            m_mouse * m_transform = m_screen
            [mx my 1] [a b 0]   [sx sy 1]
            [mx my 1] [c d 0] = [sx sy 1]
            [...    ] [e f 1]   [...    ]
            '''
            m_transform, quality = self.fit(screen_pts=[(p['sx'], p['sy']) for p in self.points],
                                       mouse_pts=[(p['mx'], p['my']) for p in self.points])
            m_transform[:, 2] = ([0], [0], [1])

        m_transform = m_transform.getT()
        return m_transform, quality


    def state_choose_dev(self):
        self.state = self.state_choose_dev
        preferred = self.choose_preferred(self.devs)
        def chosen(var):
            dev = var.get()
            if dev in self.devs.keys():
                self.state_init()
            else:
                self.state_choose_dev()
        self.ui.ask_int('Device to calibrate:', preferred, chosen)

    def state_init(self):
        self.state = self.state_init
        self.n_points = 8

        self.n_cols = int(math.ceil(math.sqrt(self.n_points)))
        self.n_rows = int(math.ceil(self.n_points / self.n_cols))

        self.X, self.Y = None, None
        self.point, self.points = {}, []
        self.index = -1

        new_cal = None
        self.ui.ask_yesno('Calibrate?', yes=self.state_cal_init, no=self.state_test)

    def got_click(self, sx, sy, ex, ey):
        ox, oy = ex/self.ui.X, ey/self.ui.Y  # old-calibrated
        self.ui.indicator(sx, sy, ox, oy, '#00F')

        ux, uy = self.calibrator.transform(ox, oy, self.calibrator.old_cal_inv)  # uncalibrated
        self.ui.indicator(sx, sy, ux, uy, '#000')

        if self.calibrator.new_cal is not None:
            nx, ny = self.transform(ux, uy, self.calibrator.new_cal)  # new-calibrated (test only)
            self.ui.indicator(sx, sy, nx, ny, '#0F0')

        self.point.update({'mx': ux, 'my': uy})
        self.points.append(self.point)

        # Wake up state machine in 500ms
        self.ui.after(0.5, self.state)

    def state_cal_init(self):
        self.ui.show_workarea(self.state_cal)

    def state_cal(self):
        self.state = self.state_cal
        #if self.disable_rot is None:
        #    self.disable_rot = self.ui.ask_yesno('Disable rotation?')
        # TODO please do better here!
        disable_rot = False
        if self.index >= self.n_points:
            self.state_done_cal()

        self.ui.sensitive = True
        x = 0.1 + 0.8*(self.index % self.n_cols)/(self.n_cols - 1)
        y = 0.1 + 0.8*(self.index // self.n_cols)/(self.n_rows - 1)
        self.point = {'sx': x, 'sy': y}

        self.ui.next_point(self.point['sx'], self.point['sy'], self.got_click)

    def state_done_cal(self):
        self.state = self.state_done_cal
        self.ui.sensitive = False

        new_cal, quality = self.calibrate(self.points, disable_rot)
        message = 'New calibration:'
        message += "\n"+str(new_cal)
        message += '\nQuality (should be at least 3): %.1f' % quality
        self.ui.show_info(message, done=self.state_test)

    def state_test(self):
        self.state = self.state_test
        self.n_points = self.choose_points()
        self.show_tk(self.n_points, old_cal_inv, new_cal)

    def ui_ready(self, event):
        self.X = event.width
        self.Y = event.height
        #self.state()

    def run(self):

        self.X, self.Y = None, None
        self.point, self.points = {}, []
        self.index = -1
        self.ui.after(0.5, self.state)
        # Pass control to UI
        self.ui.run()
        #if new_cal is not None and self.ui.ask_yesno('Use calibration?'):
        #    self.use_cal(dev, new_cal)

    def __init__(self, ui, dev_to_calibrate=None, num_points=None, disable_rot=False):
        '''
        Create a new calibrator instance.

        Takes the UI base class and instanciates it.
        '''
        self.ui = ui(self)
        self.devs = self.get_devs()

        #self.old_cal, self.old_cal_inv = self.read_cal(dev)

        self.state = self.state_choose_dev

class xcal_xinput(xcal_base):
    prop_name = 'libinput Calibration Matrix'

    def xinput(self, *args):
        return run(args=('/usr/bin/xinput', *args),
                   stdout=PIPE, check=True,
                   universal_newlines=True).stdout


    def get_devs(self):
        devs = {int(groups[1]): groups[0] for groups in
                re.findall(r'↳ (\w.+\w)\s+id=(\d+)\D+slave *pointer',
                           self.xinput('--list', '--short'))}
        if not devs:
            print('No suitable input devices found')
            exit(1)
        return devs


    def print_devs(self, devs):
        msg = "\n".join(('Pointer devices:',
                        '%4s %35s' % ('ID', 'Name')))

        for i, name in sorted(devs.items()):
            msg+=('\n%4d %35s' % (i, name))
        self.ui.show_info(msg)

    def choose_preferred(self, devs):
        preferred = [i for (i, n) in devs.items() if 'touch' in n.lower()]
        if preferred:
            return preferred[0]
        return next(iter(devs.keys()))

    def read_cal(self, dev):
        stdout = self.xinput('--list-props', str(dev))
        line = re.search(self.prop_name + r'.*:\s+(\S.+)', stdout)
        if not line:
            print('Cal property not set; is this an xinput device?')
            exit(1)
        vals = np.matrix(line.group(1)).reshape(3, 3)

        print('Old calibration:')
        print(vals)
        print()
        return vals, np.linalg.inv(vals)


    def choose_points(self):
        p_min, default = 3, 4

        while True:
            p_str = self.ui.ask_int('Point count (min %d): ' % p_min, default)
            try:
                p = int(p_str)
            except ValueError:
                continue

            if p >= p_min:
                return p

    def use_cal(self, dev, new_cal):
        cal_array = [str(x)+',' for x in new_cal.flatten().tolist()[0]]
        self.xinput('--set-prop', str(dev), prop_name, *cal_array)


cal=xcal_xinput(GUI)
cal.run()
#main()
